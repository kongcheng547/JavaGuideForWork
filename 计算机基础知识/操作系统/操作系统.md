# 操作系统

## 中断分类

1. 外部中断，是CPU指令以外的事情引起的，如IO处理等
2. 异常：内部事件错误引起，如非法操作码，地址越界，算术错误等
3. 陷入：trap，系统调用等。

## 进程管理

### 进程与线程

1. 进程是资源分配的基本单位，PCB管理。线程是调度的基本单位，一个进程多个线程，共享资源。
2. 进程拥有资源但是线程不拥有资源，线程是访问属于进程的资源。进程切换的系统开销比线程大得多，因为线程只用切换一下寄存器状态等就可以了。线程用直接读写同一个进程中的数据进行通信，而进程通信需要借助IPC。
3. 进程状态有：created->ready->running->terminated。running可能会到waiting->ready，就是因为IO等进行了阻塞，等待资源。进程在running的时候interrupt可以再回到ready状态。

### 进程同步互斥

1. 临界区，同步是先后进入，互斥是只能一个进入。
2. 信号量Semaphore是一个整型变量，对其执行PV操作。要先对信号量操作再对mutex操作，否则会导致一直等待。
3. 管程，wait和signal操作，

### 进程通信

1. 管道，一个读一个写，但是是半双工的，单相交替通信，只能在父子或者兄弟进程之间进行使用。

2. FIFO，命名管道，可以用于客户服务端应用程序之间，当做是一个汇聚点，在客户和服务端之间传递消息。

   <img src="操作系统.assets/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png" alt="img" style="zoom:50%;" />

3. 消息队列：这个可以独立于读写进程存在，避免FIFO中同步管道的打开和关闭时可能产生的困难。避免了FIFO里面的阻塞问题，不用进程提供同步的方法，读进程可以根据消息类型有选择地接收消息，而不用像FIFO一样只能被动接收。

4. 信号量：是一个计数器，作为进程同步的条件。

5. 共享内存：多个进程共享一个给定的存储区，因为不需要进程之间复制所以是最快的一种IPC，需要信号量进行内存的同步访问。多个进程可以将同一个文件映射到自己的空间从而实现共享内存

6. 套接字socket

## 死锁

### 死锁的四个必要条件

1. 互斥，资源之间不可共享
2. 占有且等待
3. 不可抢占
4. 环路等待

Java模拟死锁，两个资源分别有锁访问，T1得到1资源，先sleep(1000)，然后等待2资源。

T2先获得2资源，然后申请获得1资源，二者就达成了死锁。

### 处理死锁的思路

1. 鸵鸟策略，一些死锁概率低且影响小，所以鸵鸟策略，不管它，大多数操作系统都是如此
2. 死锁检测：多个资源的时候死锁的检测，主要是看有没有形成环
3. 死锁恢复：抢占进程、回滚、杀死进程
4. 死锁预防：破坏死锁的四个条件，转账的时候我检测你的账户是否加锁，没有加锁就给自己加上然后进行转账
5. 死锁避免：看当前的需求满足之后会不会造成死锁，只要有一条路可以全部分配就可以。银行家算法，检查是否安全。

## 内存管理

### 虚拟内存

1. 不需要完整的连续的物理空间，这个通常是无法实现的，可以实现看起来是完整的。也不需要所有都一起调入内存，只在需要的时候进行调入或者置换即可。
2. 内存管理单元MMU，页表，一个虚拟地址，前面几位是页号，后面几位是页内偏移。
3. 页面置换算法，缺页管理，希望缺页次数少。
   1. 最佳策略，最长不被使用的置换出去。但是不知道到底要用哪一个页面
   2. LRU的实现
   3. 最近未使用，优先换出脏页面
   4. 先进先出
   5. 时钟算法，clock，把指过的数字更改一下，一圈之后没有发现则还是第一个被置换。
4. 段页式存储管理，先分段又分页，注意段号之类的在地址中的表示。分页是方便实现虚拟内存，分段是有助于隔离保护一段内容，获得一段干净的地址空间。