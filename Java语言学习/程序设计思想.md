# 程序设计思想

## 面向对象思想

### 一、三大特性

#### 封装

利用抽象数据类型将数据和基于数据的操作封装到一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能隐藏内部的细节，只保留对外的接口使其与外部发生关系，用户无需关心对象内部的细节，但可通过对象对外访问的接口来访问该对象。

##### 优点

1. 减少耦合，可以独立各模块，各自进行开发、测试、优化、使用、理解和修改
2. 减轻维护的负担，更容易被理解，调试的时候不影响其他模块
3. 有效地调节性能，可以通过剖析来确定哪些模块影响了系统的性能
4. 提高软件的可重用性
5. 降低了构建大型系统的风险，即使整个系统不可用，但是这些独立的模块却有可能是可用的

#### 继承

继承实现了IS-A关系，继承要1实现里式替换原则，子类对象必须可以替换掉所有父类对象。父类引用指向子类对象称为向上转型。响应方法都是看子类是否重写来决定用谁。

#### 多态

多态分为编译时多态和运行时多态

+ 编译时多态指的是方法的重写
+ 运行时多态指的是程序中定义的对象的引用所指向的具体类型在运行期间才确定，有三个条件，继承、重写、向上转型，即父类引用指向子类对象。

### 二、设计原则

#### SOLID原则

| 简写 |                全拼                 |   中文翻译   |
| :--: | :---------------------------------: | :----------: |
| SRP  | The Single Responsibility Principle | 单一责任原则 |
| OCP  |      The Open Closed Principle      | 开放封闭原则 |
| LSP  |  The Liskov Substitution Principle  | 里氏替换原则 |
| ISP  | The Interface Segregation Principle | 接口分离原则 |
| DIP  | The Dependency Inversion Principle  | 依赖倒置原则 |

1. 单一责任原则，修改一个类的原因应该只有一个，换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。

   如果一个类承担责任过多，那么一个职责的变化可能会削弱这类其他职责的能力

2. 开放封闭原则，类应该对扩展开放，但是对修改关闭。扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码，只是添加部分代码。符合这个原则最典型的设计模式是装饰者模式，他可以动态地将责任附加到对象上，而不用去修改类的代码。

3. 里式替换原则，子类对象必须能替换掉所有父类对象，继承是一种IS-A关系，子类需要能够当成父类来使用，而且需要比父类更加特殊。如果不满足这个原则，那么各个子类之间的关系就会有很大差异，增加继承体系的复杂度。

4. 接口分离原则，不应该强迫用户依赖于他们不用的方法，因此使用多个专门的接口比一个单一的总接口要好

5. 依赖倒置原则，高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动会直接影响到高层，从而迫使高层模块也需要改动。

   依赖于抽象意味着：

   + 任何变量都不应该持有一个指向具体类的指针或者引用。
   + 任何类都不应该从具体类中派生
   + 任何方法都不应该覆写它的基类中已经实现的方法

#### 其他常见原则

| 简写 |               全拼                |   中文翻译   |
| :--: | :-------------------------------: | :----------: |
| LOD  |        The Law of Demeter         |  迪米特法则  |
| CRP  |   The Composite Reuse Principle   | 合成复用原则 |
| CCP  |   The Common Closure Principle    | 共同封闭原则 |
| SAP  | The Stable Abstractions Principle | 稳定抽象原则 |
| SDP  | The Stable Dependencies Principle | 稳定依赖原则 |

1. 迪米特法则：又叫做最少知识原则，Least Knowledge principle，LKP，就是说一个对象应当对其他对象尽可能少得了解，少和陌生人说话。
2. 合成复用原则，尽量用对象组合而不是继承来达到复用的目的。即不要为了一个功能随便继承，可以尝试用两个对象来实现功能。
3. 共同封闭原则，一起修改的类，应该组合在一起(同一个包中)，如果必须修改应用程序里的代码，我们希望修改只是发生在一个包里而不是很多包。
4. 稳定抽象原则，最稳定的包应该是最抽象的包，不稳定的应该是具体的包，即越抽象越不要改
5. 稳定依赖原则，包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。

## 设计模式













