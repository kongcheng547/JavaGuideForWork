# 算法学习

## 2021年始

### 2.4 leetcode初始刷题

1. 两数之和

   ```
   输入：nums = [2,7,11,15], target = 9
   输出：[0,1]
   解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 
   ```

   一开始只会暴力解题：

   ```java
   class Solution {
       public int[] twoSum(int[] nums, int target) {
           for(int i=0;i<nums.length;i++){
               for(int j=i+1;j<nums.length;j++){
                   if(nums[i]+nums[j]==target){
                       int r[]=new int[2];
                       r[0]=i;
                       r[1]=j;
                       return r;
                   }
               }
           }
           return new int[2];
       }
   }
   //空间复杂度很高
   ```

   之后查看了他人的hashmap实现方式，自己重新写了一份

   ```java
   class Solution {
       public int[] twoSum(int[] nums, int target) {
           Map<Integer,Integer> m=new HashMap();
           int r[]=new int[2];
           for(int i=0;i<nums.length;i++){
               if(m.containsKey(target-nums[i])){
                   r[1]=i;
                   r[0]=m.get(target-nums[i]);//因为是放进去后面一半再执行的，所以顺序要调换
                   break;
               }
               m.put(nums[i],i);
           }
           return r;
       }
   }
   ```

### 2.28 刷题

1. 两个数之和，链表操作，链接https://leetcode-cn.com/problems/add-two-numbers/

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode() {}
    *     ListNode(int val) { this.val = val; }
    *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    * }
    */
   class Solution {
       public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
           int temp=0;
           ListNode r=new ListNode(0);
           ListNode p=r;
           while(l1!=null||l2!=null||temp!=0){//这里三个部分都为0说明都加完了
               int lv1=l1!=null?l1.val:0;
               int lv2=l2!=null?l2.val:0;
               int sum=lv1+lv2+temp;
               temp=sum/10;
               p.next=new ListNode(sum%10);
               p=p.next;
               if(l1!=null) l1=l1.next;
               if(l2!=null) l2=l2.next;
           }
           return r.next;//首可以是0，返回next就行
       }
   }
   ```

2. 无重复字符的最长子串长度：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/

   ```java
   class Solution {
       public int lengthOfLongestSubstring(String s) {
           int r=0;
           int last[]=new int[128];
           for(int i=0;i<128;i++){
               last[i]=-1;
           }
           int start=0;
           for(int i=0;i<s.length();i++){
               int index=s.charAt(i);
               start=Math.max(start,last[index]+1);//上一次的位置加1，因为上一次的位置不能作为头进行遍历
               r=Math.max(r,i-start+1);//获得的上一次本字符的位置作为头
               last[index]=i;
           }
           return r;
       }
   }
   ```

   参考了别人的代码思想，用数组存起来每个可能的字符的上一次出现的位置，下一次再碰到这个字符就根据它来进行遍历。

3. 找到两个有序数组的中位数：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/

   首先将中位数的奇数与偶数合并

   ```java
   int left = (n + m + 1) / 2;
   int right = (n + m + 2) / 2;
   ```

   这样就保证了奇数与偶数情况下都是一样的左加右除以二的结果。

   自己的暴力解法而且写得极为丑陋：就是合并两个数组，然后在获得实际的结果的时候

   ```java
   class Solution {
       public double findMedianSortedArrays(int[] nums1, int[] nums2) {
           int n=nums1.length,m=nums2.length;
           int left = (n + m + 1) / 2;
           int right = (n + m + 2) / 2;
           if(nums1.length==0){
               if(m==1)    return (double)nums2[0];
               return (double)(nums2[left-1]+nums2[right-1])/2;
           }
           if(nums2.length==0){
               if(n==1)    return (double)nums1[0];
               return (double)(nums1[left-1]+nums1[right-1])/2;
           }
           int[] r=new int[nums1.length+nums2.length];
           int allLen=nums1.length+nums2.length;
           int flag=1;
           int z=0,head=0,tail=0;
           if(allLen%2==1){
               z=allLen/2;
           }
           else{
               head=allLen/2-1;tail=allLen/2;
               flag=0;
           }
           int i=0,j=0,ri=0;
           while(i<nums1.length||j<nums2.length){
               if(nums1[i]<nums2[j]){
                   r[ri]=nums1[i];
                   if(i+1!= nums1.length){
                       i++;
                   }
                   else{
                       nums1[i]=1000001;
                   }
               }
               else
               {
                   r[ri]=nums2[j];
                   if(j+1!= nums2.length){
                       j++;
                   }
                   else
                   {
                       nums2[j]=1000001;
                   }
               }
               if(flag==0&&ri>=tail){
                   double ret=(r[head]+r[tail])/2.0;
                   return ret;
               }
               else if(flag==1&&ri>=z){
                   return (double)r[z];
               }
               ri++;
           }
           return 0;
       }
   }
   ```

   