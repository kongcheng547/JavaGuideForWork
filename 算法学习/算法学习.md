# 算法学习

## 2021年始

### 2.4 leetcode初始刷题

1. 两数之和

   ```
   输入：nums = [2,7,11,15], target = 9
   输出：[0,1]
   解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 
   ```

   一开始只会暴力解题：

   ```java
   class Solution {
       public int[] twoSum(int[] nums, int target) {
           for(int i=0;i<nums.length;i++){
               for(int j=i+1;j<nums.length;j++){
                   if(nums[i]+nums[j]==target){
                       int r[]=new int[2];
                       r[0]=i;
                       r[1]=j;
                       return r;
                   }
               }
           }
           return new int[2];
       }
   }
   //空间复杂度很高
   ```

   之后查看了他人的hashmap实现方式，自己重新写了一份

   ```java
   class Solution {
       public int[] twoSum(int[] nums, int target) {
           Map<Integer,Integer> m=new HashMap();
           int r[]=new int[2];
           for(int i=0;i<nums.length;i++){
               if(m.containsKey(target-nums[i])){
                   r[1]=i;
                   r[0]=m.get(target-nums[i]);//因为是放进去后面一半再执行的，所以顺序要调换
                   break;
               }
               m.put(nums[i],i);
           }
           return r;
       }
   }
   ```

### 2.28 刷题

1. 两个数之和，链表操作，链接https://leetcode-cn.com/problems/add-two-numbers/

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode() {}
    *     ListNode(int val) { this.val = val; }
    *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    * }
    */
   class Solution {
       public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
           int temp=0;
           ListNode r=new ListNode(0);
           ListNode p=r;
           while(l1!=null||l2!=null||temp!=0){//这里三个部分都为0说明都加完了
               int lv1=l1!=null?l1.val:0;
               int lv2=l2!=null?l2.val:0;
               int sum=lv1+lv2+temp;
               temp=sum/10;
               p.next=new ListNode(sum%10);
               p=p.next;
               if(l1!=null) l1=l1.next;
               if(l2!=null) l2=l2.next;
           }
           return r.next;//首可以是0，返回next就行
       }
   }
   ```

2. 无重复字符的最长子串长度：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/

   ```java
   class Solution {
       public int lengthOfLongestSubstring(String s) {
           int r=0;
           int last[]=new int[128];
           for(int i=0;i<128;i++){//元素的修改必须用for循环，只是遍历可以用foreach循环
               last[i]=-1;
           }
           int start=0;
           for(int i=0;i<s.length();i++){
               int index=s.charAt(i);
               start=Math.max(start,last[index]+1);//上一次的位置加1，因为上一次的位置不能作为头进行遍历
               r=Math.max(r,i-start+1);//获得的上一次本字符的位置作为头
               last[index]=i;
           }
           return r;
       }
   }
   ```

   参考了别人的代码思想，用数组存起来每个可能的字符的上一次出现的位置，下一次再碰到这个字符就根据它来进行遍历。

   

3. 找到两个有序数组的中位数：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/

   首先将中位数的奇数与偶数合并 

   **没有看懂第k小的方法，再看**
   
   ```java
   int left = (n + m + 1) / 2;
int right = (n + m + 2) / 2;
   ```

   这样就保证了奇数与偶数情况下都是一样的左加右除以二的结果。

   自己的暴力解法而且写得极为丑陋：就是合并两个数组，然后在获得实际的结果的时候
   
   ```java
   class Solution {
       public double findMedianSortedArrays(int[] nums1, int[] nums2) {
           int n=nums1.length,m=nums2.length;
           int left = (n + m + 1) / 2;
           int right = (n + m + 2) / 2;
           if(nums1.length==0){
               if(m==1)    return (double)nums2[0];
               return (double)(nums2[left-1]+nums2[right-1])/2;
           }
           if(nums2.length==0){
               if(n==1)    return (double)nums1[0];
               return (double)(nums1[left-1]+nums1[right-1])/2;
           }
           int[] r=new int[nums1.length+nums2.length];
           int allLen=nums1.length+nums2.length;
           int flag=1;
           int z=0,head=0,tail=0;
           if(allLen%2==1){
               z=allLen/2;
           }
           else{
               head=allLen/2-1;tail=allLen/2;
               flag=0;
           }
           int i=0,j=0,ri=0;
           while(i<nums1.length||j<nums2.length){
               if(nums1[i]<nums2[j]){
                   r[ri]=nums1[i];
                   if(i+1!= nums1.length){
                       i++;
                   }
                   else{
                       nums1[i]=1000001;
                   }
               }
               else
               {
                   r[ri]=nums2[j];
                   if(j+1!= nums2.length){
                       j++;
                   }
                   else
                   {
                       nums2[j]=1000001;
                   }
               }
               if(flag==0&&ri>=tail){
                   double ret=(r[head]+r[tail])/2.0;
                   return ret;
               }
               else if(flag==1&&ri>=z){
                   return (double)r[z];
               }
               ri++;
           }
           return 0;
       }
}
   ```

### 3.1 剑指offer刷题

1. 找出数组中任意一个重复的元素：

   https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/

   应该问面试官处理的需求，是要时间还是空间，我用了set的方法，但是时间太长，

   ```java
   class Solution {
       public int findRepeatNumber(int[] nums) {
           Set<Integer> s=new HashSet<>();
           for(int i=0;i<nums.length;i++){
               if(s.contains(nums[i])){
                   return nums[i];
               }
               s.add(nums[i]);
           }
           return nums[0];
       }
   }
   ```

   别人的快速代码，不需要set拖慢速度

   时间2ms，但是空间用的较大了

   ```java
   class Solution {
       public int findRepeatNumber(int[] nums) {
           int arr[]=new int[nums.length];
           for(int i=0;i<nums.length;i++){
               arr[nums[i]]++;
               if(arr[nums[i]]>1) return nums[i];
           }
           return nums[0];
       }
   }
   ```

   继续借鉴别人的代码，原地置换，因为数组是0-n的，那么按理来说应该数字i就在i的位置，如果不是我们就进行置换，然后下次再碰到i正好在i位置说明本数字就重复了，返回

   ```java
   class Solution {
       public int findRepeatNumber(int[] nums) {
           int temp;
           for(int i=0;i<nums.length;i++){
               while(nums[i]!=i){
                   if(nums[i]==nums[nums[i]]){
                       return nums[i];
                   }
                   temp=nums[i];
                   nums[i]=nums[temp];
                   nums[temp]=temp;
               }
           }
           return -1;
       }
   }
   ```

   这个时间0ms，不知道为什么短得多，空间反而较大，可能是leetcode的测试案例不一样。

2. 替换字符串里面的空格变为%20，如果不用库函数就用SrtingBuilder，StringBuffer什么的要再看

   https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/submissions/

   ```
   class Solution {
       public String replaceSpace(String s) {
           return s.replace(" ","%20");
       }
   }
   ```

3. 根据中序和前序遍历重建树

   https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/comments/

   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       public TreeNode buildTree(int[] preorder, int[] inorder) {
           if(preorder.length==0)  return null;
           int rootVal=preorder[0],rootIndex=0;
           for(int i=0;i<inorder.length;i++){
               if(rootVal==inorder[i]){
                   rootIndex=i;
                   break;
               }
           }
           TreeNode root=new TreeNode(rootVal);
           root.left=buildTree(Arrays.copyOfRange(preorder,1,1+rootIndex),Arrays.copyOfRange(inorder,0,rootIndex));
           int n=preorder.length;
           root.right=buildTree(Arrays.copyOfRange(preorder,1+rootIndex,n),Arrays.copyOfRange(inorder,rootIndex+1,n));//copyOfRange的范围是左闭右开的区间
           return root;
       }
   }
   ```

   - 前序遍历列表：第一个元素永远是 【根节点 (root)】
   - 中序遍历列表：根节点 (root)【左边】的所有元素都在根节点的【左分支】，【右边】的所有元素都在根节点的【右分支】

   算法思路：

   1. 通过【前序遍历列表】确定【根节点 (root)】
   2. 将【中序遍历列表】的节点分割成【左分支节点】和【右分支节点】
   3. 递归寻找【左分支节点】中的【根节点 (left child)】和 【右分支节点】中的【根节点 (right child)】

4. 

