# 算法学习

## 2021年始

### 2.4 leetcode初始刷题

1. 两数之和

   ```
   输入：nums = [2,7,11,15], target = 9
   输出：[0,1]
   解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 
   ```

   一开始只会暴力解题：

   ```java
   class Solution {
       public int[] twoSum(int[] nums, int target) {
           for(int i=0;i<nums.length;i++){
               for(int j=i+1;j<nums.length;j++){
                   if(nums[i]+nums[j]==target){
                       int r[]=new int[2];
                       r[0]=i;
                       r[1]=j;
                       return r;
                   }
               }
           }
           return new int[2];
       }
   }
   //空间复杂度很高
   ```

   之后查看了他人的hashmap实现方式，自己重新写了一份

   ```java
   class Solution {
       public int[] twoSum(int[] nums, int target) {
           Map<Integer,Integer> m=new HashMap();
           int r[]=new int[2];
           for(int i=0;i<nums.length;i++){
               if(m.containsKey(target-nums[i])){
                   r[1]=i;
                   r[0]=m.get(target-nums[i]);//因为是放进去后面一半再执行的，所以顺序要调换
                   break;
               }
               m.put(nums[i],i);
           }
           return r;
       }
   }
   ```

### 2.28 刷题

1. 两个数之和，链表操作，链接https://leetcode-cn.com/problems/add-two-numbers/

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode() {}
    *     ListNode(int val) { this.val = val; }
    *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    * }
    */
   class Solution {
       public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
           int temp=0;
           ListNode r=new ListNode(0);
           ListNode p=r;
           while(l1!=null||l2!=null||temp!=0){//这里三个部分都为0说明都加完了
               int lv1=l1!=null?l1.val:0;
               int lv2=l2!=null?l2.val:0;
               int sum=lv1+lv2+temp;
               temp=sum/10;
               p.next=new ListNode(sum%10);
               p=p.next;
               if(l1!=null) l1=l1.next;
               if(l2!=null) l2=l2.next;
           }
           return r.next;//首可以是0，返回next就行
       }
   }
   ```

2. 无重复字符的最长子串长度：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/

   ```java
   class Solution {
       public int lengthOfLongestSubstring(String s) {
           int r=0;
           int last[]=new int[128];
           for(int i=0;i<128;i++){//元素的修改必须用for循环，只是遍历可以用foreach循环
               last[i]=-1;
           }
           int start=0;
           for(int i=0;i<s.length();i++){
               int index=s.charAt(i);
               start=Math.max(start,last[index]+1);//上一次的位置加1，因为上一次的位置不能作为头进行遍历
               r=Math.max(r,i-start+1);//获得的上一次本字符的位置作为头
               last[index]=i;
           }
           return r;
       }
   }
   ```

   参考了别人的代码思想，用数组存起来每个可能的字符的上一次出现的位置，下一次再碰到这个字符就根据它来进行遍历。

   

3. 找到两个有序数组的中位数：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/

   首先将中位数的奇数与偶数合并 

   **没有看懂第k小的方法，再看**
   
   ```java
   int left = (n + m + 1) / 2;
int right = (n + m + 2) / 2;
   ```

   这样就保证了奇数与偶数情况下都是一样的左加右除以二的结果。

   自己的暴力解法而且写得极为丑陋：就是合并两个数组，然后在获得实际的结果的时候
   
   ```java
   class Solution {
       public double findMedianSortedArrays(int[] nums1, int[] nums2) {
           int n=nums1.length,m=nums2.length;
           int left = (n + m + 1) / 2;
           int right = (n + m + 2) / 2;
           if(nums1.length==0){
               if(m==1)    return (double)nums2[0];
               return (double)(nums2[left-1]+nums2[right-1])/2;
           }
           if(nums2.length==0){
               if(n==1)    return (double)nums1[0];
               return (double)(nums1[left-1]+nums1[right-1])/2;
           }
           int[] r=new int[nums1.length+nums2.length];
           int allLen=nums1.length+nums2.length;
           int flag=1;
           int z=0,head=0,tail=0;
           if(allLen%2==1){
               z=allLen/2;
           }
           else{
               head=allLen/2-1;tail=allLen/2;
               flag=0;
           }
           int i=0,j=0,ri=0;
           while(i<nums1.length||j<nums2.length){
               if(nums1[i]<nums2[j]){
                   r[ri]=nums1[i];
                   if(i+1!= nums1.length){
                       i++;
                   }
                   else{
                       nums1[i]=1000001;
                   }
               }
               else
               {
                   r[ri]=nums2[j];
                   if(j+1!= nums2.length){
                       j++;
                   }
                   else
                   {
                       nums2[j]=1000001;
                   }
               }
               if(flag==0&&ri>=tail){
                   double ret=(r[head]+r[tail])/2.0;
                   return ret;
               }
               else if(flag==1&&ri>=z){
                   return (double)r[z];
               }
               ri++;
           }
           return 0;
       }
}
   ```

### 3.1 剑指offer刷题

1. 找出数组中任意一个重复的元素：

   https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/

   应该问面试官处理的需求，是要时间还是空间，我用了set的方法，但是时间太长，

   ```java
   class Solution {
       public int findRepeatNumber(int[] nums) {
           Set<Integer> s=new HashSet<>();
           for(int i=0;i<nums.length;i++){
               if(s.contains(nums[i])){
                   return nums[i];
               }
               s.add(nums[i]);
           }
           return nums[0];
       }
   }
   ```

   别人的快速代码，不需要set拖慢速度

   时间2ms，但是空间用的较大了

   ```java
   class Solution {
       public int findRepeatNumber(int[] nums) {
           int arr[]=new int[nums.length];
           for(int i=0;i<nums.length;i++){
               arr[nums[i]]++;
               if(arr[nums[i]]>1) return nums[i];
           }
           return nums[0];
       }
   }
   ```

   继续借鉴别人的代码，原地置换，因为数组是0-n的，那么按理来说应该数字i就在i的位置，如果不是我们就进行置换，然后下次再碰到i正好在i位置说明本数字就重复了，返回

   ```java
   class Solution {
       public int findRepeatNumber(int[] nums) {
           int temp;
           for(int i=0;i<nums.length;i++){
               while(nums[i]!=i){
                   if(nums[i]==nums[nums[i]]){
                       return nums[i];
                   }
                   temp=nums[i];
                   nums[i]=nums[temp];
                   nums[temp]=temp;
               }
           }
           return -1;
       }
   }
   ```

   这个时间0ms，不知道为什么短得多，空间反而较大，可能是leetcode的测试案例不一样。

2. 替换字符串里面的空格变为%20，如果不用库函数就用SrtingBuilder，StringBuffer什么的要再看

   https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/submissions/

   ```
   class Solution {
       public String replaceSpace(String s) {
           return s.replace(" ","%20");
       }
   }
   ```

3. 根据中序和前序遍历重建树

   https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/comments/

   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       public TreeNode buildTree(int[] preorder, int[] inorder) {
           if(preorder.length==0)  return null;
           int rootVal=preorder[0],rootIndex=0;
           for(int i=0;i<inorder.length;i++){
               if(rootVal==inorder[i]){
                   rootIndex=i;
                   break;
               }
           }
           TreeNode root=new TreeNode(rootVal);
           root.left=buildTree(Arrays.copyOfRange(preorder,1,1+rootIndex),Arrays.copyOfRange(inorder,0,rootIndex));
           int n=preorder.length;
           root.right=buildTree(Arrays.copyOfRange(preorder,1+rootIndex,n),Arrays.copyOfRange(inorder,rootIndex+1,n));//copyOfRange的范围是左闭右开的区间
           return root;
       }
   }
   ```

   - 前序遍历列表：第一个元素永远是 【根节点 (root)】
   - 中序遍历列表：根节点 (root)【左边】的所有元素都在根节点的【左分支】，【右边】的所有元素都在根节点的【右分支】

   算法思路：

   1. 通过【前序遍历列表】确定【根节点 (root)】
   2. 将【中序遍历列表】的节点分割成【左分支节点】和【右分支节点】
   3. 递归寻找【左分支节点】中的【根节点 (left child)】和 【右分支节点】中的【根节点 (right child)】


### 3.2剑指offer

1. 二维数组的查找，二维数组每一个元素都比右边和下面小，找一个快速的查找方法，如从右上角开始查找，目标比当前元素大就左移，比它小就向下，等于就返回，最后找完没有return就代表没有找到，注意都要判断边界条件如为空的时候要返回false。

   https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/submissions/

   ```java
   class Solution {
       public boolean findNumberIn2DArray(int[][] matrix, int target) {
           if(matrix==null||matrix.length==0)   return false;
           int col=matrix[0].length-1,row=0;
           while(col>=0&&row<matrix.length){
               if(matrix[row][col]==target)    return true;
               else if(matrix[row][col]>target){
                   col--;
               }
               else if(matrix[row][col]<target){
                   row++;
               }
           }
           return false;
       }
   }
   ```

2. 用两个堆栈实现一个队列https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/submissions/

   就是用两个栈模拟队列的运作，其中Java的堆栈Stack较慢，建议用LinkedList，因为其速度较快，用add替代其push操作，pop操作本身也有

   ```java
   class CQueue {
   
       LinkedList<Integer> s1,s2;
       public CQueue() {
           s1=new LinkedList<>();
           s2=new LinkedList<>();
       }
       
       public void appendTail(int value) {
           s1.add(value);
       }
       
       public int deleteHead() {
           if(s2.isEmpty()){
            if(s1.isEmpty()){
               return -1;
           }
           while(!s1.isEmpty()){
               int temp=s1.pop();
               s2.add(temp);
           }   
           return s2.pop();
           }else return s2.pop();
           
       }
   }
   
   /**
    * Your CQueue object will be instantiated and called as such:
    * CQueue obj = new CQueue();
    * obj.appendTail(value);
    * int param_2 = obj.deleteHead();
    */
   ```

3. 求第n个斐波那契数https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/submissions/

   ```java
   class Solution {
       public int fib(int n) {
           int f1=0,f2=1;
           if(n==0)return 0;
           if(n==1)return 1;
           int temp=0;
           for(int i=2;i<=n;i++){
               temp=f2+f1;
               f1=f2;
               f2=temp%1000000007;//每次都要取余数
           }
           return f2;
       }
   }
   ```

4. 青蛙跳台阶，其实就是斐波那契数列问题，因为从上面一个台阶或者两个台阶跳过来

   如果第一次跳的是1级台阶，那么剩下n-1级台阶，跳法是f(n-1)
   如果第一次跳的是2级台阶，那么剩下n-2级台阶，跳法是f(n-2)
   可以得出总跳法为: f(n) = f(n-1) + f(n-2)
   由题意可得：没有台阶的时候f(0) = 1，只有一级台阶的时候 f(1) = 1
   可以发现最终得出的是一个斐波那契数列：

   https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution/

   所以

   ```java
   class Solution {
       public int numWays(int n) {
           if(n<=1)    return 1;
           if(n==2)    return 2;
           int f1=1,f2=2,temp=0;
           for(int i=2;i<n;i++){
               temp=f1+f2;
               f1=f2;
               f2=temp%1000000007;
           }
           return f2;
       }
   }
   ```

5. 找到旋转数组的最小值，就是给一个升序的数组，其顺序有过一定的改变，然后找到其最小值，

   https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/

   ```java
   class Solution {
       public int minArray(int[] numbers) {
           int left=0,right=numbers.length-1,mid=0;
           while(left<right){
               mid=(left+right)/2;
               if(numbers[mid]>numbers[right]) left=mid+1;
               else if(numbers[mid]<numbers[right])    right=mid;
               else if(numbers[mid]==numbers[right])   right--;//缩短右边界距离
           }
           return numbers[left];
       }
   }
   ```

   就用二分的思想，中间的值大于右边的，说明还在左边递增的数组里面，如果小于说明在右边递增的数组里，如果等于则需要减少右边界距离直到其不再是等于。

6. 矩阵中的路径，就是一个宽度或者深度搜索，我用的是回溯+dfs的方法，找到一条路径

   https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/

   ```java
   class Solution {
       int findLength=0;
       public boolean exist(char[][] board, String word) {
           char a=word.charAt(0);
           for(int i=0;i<board.length;i++){
               for(int j=0;j<board[0].length;j++){
                   if(board[i][j]==a){
                       findLength=0;
                       board[i][j]='-';
                       findLength++;
                       boolean r=dfs(board,word,i,j);
                       board[i][j]=a;
                       if(r)   return true;
                   }
               }
           }
           return false;
       }
       public boolean dfs(char[][] board,String word,int m,int n){
           if(findLength==word.length()) return true;
           if(m-1>=0&&board[m-1][n]==word.charAt(findLength)){
               board[m-1][n]='-';
               findLength++;
               boolean r=dfs(board,word,m-1,n);
               board[m-1][n]=word.charAt(--findLength);
               if(r)   return true;
           }
           if(m+1<board.length&&board[m+1][n]==word.charAt(findLength)){
               board[m+1][n]='-';
               findLength++;
               boolean r=dfs(board,word,m+1,n);
               board[m+1][n]=word.charAt(--findLength);
               if(r)   return true;
           }
           if(n-1>=0&&board[m][n-1]==word.charAt(findLength)){
               board[m][n-1]='-';
               findLength++;
               boolean r=dfs(board,word,m,n-1);
               board[m][n-1]=word.charAt(--findLength);
               if(r)   return true;
           }
           if(n+1<board[0].length&&board[m][n+1]==word.charAt(findLength)){
               board[m][n+1]='-';
               findLength++;
               boolean r=dfs(board,word,m,n+1);
               board[m][n+1]=word.charAt(--findLength);
               if(r)   return true;
           }
           return false;
       }
   }
   ```

   回溯其实就是递归里面，找准条件，在用完之后恢复原样就行。

7. 机器人的运动范围https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/

   地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

   ```java
   class Solution {
       public int movingCount(int m, int n, int k) {
           boolean vi[][]=new boolean[m][n];
           return dfs(0,0,vi,k,m,n);
       }
       public int dfs(int row,int col,boolean vi[][],int k,int m,int n){
           if(row<0||col<0||row>=m||col>=n||vi[row][col]||(row/10+row%10+col/10+col%10)>k){
               return 0;
           }
           vi[row][col]=true;
           return dfs(row+1,col,vi,k,m,n)+dfs(row,col+1,vi,k,m,n)+1;
       }
   }
   ```

   其实就是一个dfs，一个一个找就行，我以为有什么快速解法的

8. 剪绳子：https://leetcode-cn.com/problems/jian-sheng-zi-lcof/

   只会一个简单的回溯，这样虽然测试暂时没问题，但是超出了时间限制

   ```java
   class Solution {
       int duan[];
       int index=0;
       int maxMul=0;
       public int cuttingRope(int n) {
           duan=new int[n];
           dfs(n,0);
           return maxMul;
       }
       public void dfs(int n,int time){
           if(n==0){
               int mul=1;
               for(int i=0;i<duan.length&&duan[i]!=0;i++){
                   mul*=duan[i];
               }
               maxMul=Math.max(mul,maxMul);
               return ;
           }
           if(time==0)
           {
               time++;
               for(int i=1;i<n;i++){
               duan[index]=i;
               index++;
               dfs(n-i,time);
               index--;
               duan[index]=0;
           }
           }
           else{
               for(int i=1;i<=n;i++){
               duan[index]=i;
               index++;
               dfs(n-i,time);
               index--;
               duan[index]=0;
           }
           }
           return ;
       }
   }
   ```

   学到了以下解法：

   ```java
   class Solution {
       
       public int cuttingRope(int n) {
          if(n==1||n==2){
              return 1;
          }
          else if(n==3) return 2;
          else if(n>=3){
              int mul=1;
              while(n>4){//等于4的时候分为2 2更好，如果是>=3会被分为1 3这样小一些了
                  mul*=3;
                  n-=3;
              }
              return mul*n;
          }
          return 1;
       }
   }
   ```

   原理就是3作为底数乘积是最好的，而且个数越多其乘积越大，数论的知识

   ```java
   class Solution {
       
       public int cuttingRope(int n) {
          int dp[]=new int[n+1];
          dp[2]=1;//n=0和n=1忽略
          for(int i=3;i<n+1;i++){
              for(int j=1;j<i;j++){
                   //j即是将n从第j处分割
                   //Math.max(j*(i-j),j*dp[i-j]) 中 j*(i-j)指的是分割一次后的乘积；j*dp[i-j]指
                   //分割一次后，剩余部分继续分割后的最大乘积,前面已经求解过，所以只需要取结果
                   //下面综合起来就是，但j取不同时，与前一次j取值后的dp[i]比较，取最大值，直到j遍历完
                  dp[i]=Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));
              }
          }
          return dp[n];
       }
   }
   ```

   动态规划的思想，一次次将n提高，每次都试一下j的大小，因为切一次之后剩下的大小在前面已经算好了

9. 剪绳子2，https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/，不能再用DP，因为取余之后再max会出错，所以只能用第一种方法，即乘3的方法。也可以用Java的BigInteger运算，但是比较麻烦。

   ```java
   class Solution {
       
       public int cuttingRope(int n) {
          if(n==1||n==2){
              return 1;
          }
          else if(n==3) return 2;
          else if(n>=3){
              long mul=1;//用int会出错
              while(n>4){//等于4的时候分为2 2更好，如果是>=3会被分为1 3这样小一些了
                  mul*=3;
                  mul%=1000000007;//有取余记得每一个都取余
                  n-=3;
              }
              return (int)(mul*n%1000000007);//最后转为int
          }
          return 1;
       }
   }
   ```

10. 32位整数中1的个数，无符号右移>>>,有符号右移>>

    https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/

    更快的解法：

    ```java
    public class Solution {
        public int hammingWeight(int n) {
            int res = 0;
            while(n != 0) {
                res++;
                n &= n - 1;//这个的作用是去除最右边的一个1
            }
            return res;
        }
    }
    ```

    我的解法：

    ```java
    public class Solution {
        // you need to treat n as an unsigned value
        public int hammingWeight(int n) {
            int and=1;
            int count=0;
            for(int i=0;i<32;i++){
                int a=and&n;
                if(a!=0)count++;
                and<<=1;
            }
            return count;
        }
    }
    ```

    当然要遍历32次