# 春季实习日记

浙江亿保实习--杭州跨贸小镇10栋

## 第一周

仅两天，熟悉环境

### 4.8 周四

第一天上岗，没有账号，也不会框架什么的，所以就学习了一天的SpringBoot，具体学习日记在框架学习里面。

### 4.9 周五

1. 第二天上岗，起来迟了，打车花了不少钱，还是迟到了一些，还是没有账号。

2. 以为我精通了SpringBoot，所以让我学习queryDSL，然而学了一天学了个寂寞，一天都在和环境作斗争，都在配环境，到最后也没有配完。

3. 开了一周总结会，感觉大家会的都挺多，我也更知道后面的学习方向了，从初始到最后能进行业务开发我还有很长的路要走。

### 第一周总结

摸鱼的第一周，自己学习路子不够，学习进度跟不上，要学的东西还很多，一时间学不完，没有人指导还是走的太慢了，自己要接着走下去，希望能在一个月内实现对业务的开发。

## 第二周

### 4.13 周二

#### 问题汇总

1. 文件下载之后记得要改一下run哪里的配置，选择我们的-dev.yml文件进行run，如果没有就会导致找默认的yml文件然后错误
2. jdk版本用1.8，版本不匹配会出现很多问题。
3. 主要学习了图书馆项目，学习了部分git操作，还有整个后端流程。先在controller，然后调用service，service里面进行dao的操作，数据传输多用dto封装，可以直接对一个类的数据进行访问传输，比较简单。

### 4.14 周三

1. 对getList接口进行了完整的查看，知道了里面的数据流向，sql查询怎么做的，尤其是count的计算，List\<Predicate>的where子句，like要加%等问题
2. 熟悉Spring boot的注解，注解内容很多，还要继续背。
3. 学习Java变量等命名规范

### 4.15 周四

#### 问题记录：

1. <img src="实习日记.assets/image-20210415092544409.png" alt="image-20210415092544409" style="zoom: 80%;" />

   接口也是可以实现一个成一个对象的，这里的意思是将接口的内容注入到我们的一个引用里面，然后就可以进行使用。

   其实是注入的实现类而不是接口吗？

2. 多线程是怎么体现的？图书馆项目里面都是单线程的，因为完全够用。对于TomCat服务器来说，会提供一个大概十万左右的并发度，六七百的共同访问是可以的，即使是单线程在进行不断地轮转也是可以实现大概的并发的。像是两个用户共同借阅了一本书，最后借书是否成功还是看管理员的，所以从逻辑上防止了并发的问题。

3. 服务器的整体架构。

#### 学习记录

1. 学习了Spring cloud的总体架构，对其基础组件Eureka、Ribbon、Feign、Hystrix、Zull等都有了一个总体的了解，但是其源代码过于复杂，我没有很深入地学习相关代码
2. 用git下载的项目体验了一下Eureka、Ribbon、Feign组件，对其启动方法、常用注解有了基本的了解。

### 4.16 周五

1. 从体检订单报表0322分支切出来

2. 项目内容比较复杂，先找一个接口看清楚里面是怎么调用的。有问题的时候要进行相关的搜索，找到是哪里出了问题。

3. api模块就是封装自己的微服务代码，只给出接口的调用。我们使用别的微服务就是这样调用的：

   ```java
   @FeignClient("JBDOCTOR-COMMON")//这个是微服务的名称 是在Eureka服务器里面显示的名字
   public interface JbdAreaApiService extends JbtAreaService {
   
   }
   ```

   继承别的服务的类，其实继承的也是一个接口，这个接口是api下面的，然后真正的实现是在common里面，common对这个接口进行了一个实现，在我们调用的时候，直接用JbdAreaApiService 引用，然后Autowired把bean注入到这个引用里面，我们就可以进行相关的使用了，直接可以调用实现类里面的方法。

   每次都是定义一个api的接口，然后Controller 就implements这个接口，在接口里面定义好Mapping，连接就会转到controller的地方。其他地方也是一个接口定义了这个服务，然后autowired之后就可以用相关的引用调用需要的方法。

   我们的微服务里面有一个api服务，里面只有一些api的接口，对应的实现类controller在本身的接口里面，其他服务调用就继承这个api的接口，然后再写对应的实现类进行autowired。调用其他微服务的controller不用继承这个接口，只需要继承提供给外部的接口。

4. 分为微服务进行，这样可以方便业务解耦合，也方便进行业务速度的优化，每一个单独的服务拿出去都可以进行使用，调试等也较为方便。

5. 需要换成dev进行运行嘛，每个配置文件分别是什么意思呢？dev就是test的，默认的是正式服的

6. 要学习注解的写法，枚举类的写法。

7. ```xml
   <groupId>com.ebaolife.jbdoctor</groupId> 这个是相当于路径
   <artifactId>jbd-user-api</artifactId> 这个相当于是jar包名称
   ```

8. 有很多都是脚本进行的，比如部署到服务器上面，比如一开始的环境配置等。项目配置用的是Apollo

9. <img src="实习日记.assets/image-20210416145925601.png" alt="image-20210416145925601" style="zoom:67%;" />

   解决compile之后的Q类无法被引入的问题

### 第二周总结

1. 学习了单服务和SpringBoot，但是对配置环境还是不是很熟，数据库的连接也不是很会。
2. 学习了SpringCloud的基础组件，对其有了基本的认识，但是对代码还是不熟悉，训练不够，还是要多写多看。

## 第三周

### 4.20 周二

#### 问题询问

1. 在代码里抛出的异常是如何进行处理的？有一个全局的处理异常的地方global包里面的GlobalExceptionHandler会进行全局的处理

   ```java
      @ExceptionHandler({ServiceException.class})//调用这个异常处理
       @ResponseBody
       public Response biz(ServiceException e) {
           log.error("biz异常: {}", e.getResp());
           e.printStackTrace();
           return e.getResp();//直接返回一个error信息，有异常抛出的时候直接停止，然后转到这里进行异常的处理
       }
   ```

2. 有些字段用了Byte是为了节约空间吗？是的
3. vo和dto啥区别？vo就是view object给前端看的字段。
4. getConsultTypeInquiry是什么逻辑？已经废弃了，逻辑较为复杂。区分视频或者文字是因为医生有类型需求，比如有医生不愿意露脸，所以需要加一个类型判断处理。
5. GSON是处理json格式的类，专门进行格式的转化，我们的传输都是基于json进行的

#### 学习记录

1. 根据阿里云平台的日志进行错误的排查：

   即时反馈：
   产品与服务--容器服务--k8s-test--无状态

   一般是等待别人给出一个测试接口，熟悉代码之后找到相关的接口的controller，再去容器服务里面进行搜索，查看日志

   长期反馈： 重点是要搞清楚日期，找到报错日志信息

   日志服务--hangzhou-log--applog-test是测试服、short-applog是正式服、如果没有可以看applog

   获得报错日志之后回到代码里面dev分支全局搜索一下报错信息，然后看相关的逻辑，就查找到了相关的问题。

2. 看订单池是要先看一个限流，处理高并发的方法。然后是看im里面了解Netty的分布式实现。

3. if else可以用策略模式替代，一个接口多个实现，根据一个参数选择某一个实现，那么就相当于进行了if else的判断，这样代码比较简洁，要学设计模式。

4. im，Instant Messaging，的包结构：

   <img src="实习日记.assets/image-20210420153915493.png" alt="image-20210420153915493" style="zoom:67%;" />

   task是redis的配置包

5. Java流计算：

   ```java
           Stream<String> limit = list.stream()
                   .filter((u) -> {
                       return u.getId() % 2 == 0;
                   })// 2.1 过滤 ID 为偶数
                   .filter(u -> {
                       return u.getAge() > 24;//return是流计算里面的return，不是外面的return
                   })//  2.2 过滤 Age > 24
                   .map(m -> { //map是对每一个元素都执行相同的操作而不是变成一个map
                       return m.getUserName().toUpperCase();
                   })// 2.3 把上面筛选结果的名字变为大写
                   .sorted((o1, o2) -> {
                       return o2.compareTo(o1);
                   })// 2.4 倒序排列,o1 在前就是升序，o2 在前就是降序
                   .limit(1);// 2.5 限制输出一条数据
   ```

6. 只有西药存在购物车里面，因为购物车里面只能是西药，中药都是医生给开的。查询的id多几个没问题，不会报错。

### 4.21 周三

#### 问题询问

1. queryDSL的基础函数是什么意思，比如merge、save、flush等，save是全部批量的保存，flush是在并发有锁的环境下进行一个刷新，防止读的数据还没有进行过刷新。merge和persist都是进行修改，有entity里面的id的时候就是进行修改merge，没有对应的id就是进行添加persist。

   ```java
       public EC save(EC entity) {
           if (!entityManager.contains(entity)) {
               entityManager.persist(entity);
               return entity;//所以persist就是添加，因为是在数据库不包含entity的情况下使用的
           } else {
               return entityManager.merge(entity);
           }
       }
   ```

2. 怎么查询对应字段，字段叫什么erpOrderNo，transTime

3. 再次碰到QEntity无法引入的问题，这次reload了一下pom文件就行

4. **首先本地sql要写@Transactional，会报一个transactionRequired的错误。然后是在controller里面，调用微服务的接口implements必须要加上@RequestParam等注解得到参数，没有的话更新会失败。**

#### 学习记录

1. 直接写sql语句进行更改查询的方法

   ```java
       @Transactional(propagation = Propagation.REQUIRED)
       public boolean deleteShoppingCartProduct(Long jbuUserId, Integer shoppingCartProductId) {
           String sql = "update tps_shoping_carts set state = ?1 where jbu_user_id = ?2 and id = ?3";
           Query query = getEntityManager().createNativeQuery(sql);
           query.setParameter(1, 99);
           query.setParameter(2, jbuUserId);
           query.setParameter(3, shoppingCartProductId);
           return query.executeUpdate() == 1;
       }
   ```

   这样写不是用queryDSL进行的，如果用，需要进行的操作是，先查询用户id看是否属于本身的id，然后再进行创建entity，再调用merge方法进行修改，相当于需要进行两次数据库操作，这样用sql语句可以直接写好，一遍直接update了。

   查询一般使用find操作更简单，但是修改添加等用这个更简单。

2. 升序的方法：

   ```java
   orderSpecifiers.add(areaDao.getQEntity().id.asc());//返回升序
   ```

3. 时间查询：

   ```java
   predicates.add(QOrder.order.createdAt.before(createTimeUpper));
   ```

4. 在orderClient即本服务调用别的服务的接口处可以指定接口这样才会启动到本地的服务，否则Eureka服务器可能会找到的是测试服里面已经在跑的服务而不是本地启动的服务：

   ```java
   @FeignClient(value = "WAREHOUSE-ORDER",url="http://localhost:8080")
   public interface OrderClient extends OrderApi {
   
   }
   
   ```

5. Restful API 多用curd单词，里面用驼峰命名法。信息要看长不长，长的话要用RequestBody的形式传输而不是用很多个RequestParam。

6. 增加返回字段发货时间和erpNum，直接在Vo里面增加一个值就行，因为是dto到Vo直接复制的。

7. 增加一个修改发货信息的接口，学习了很多代码规范问题。

### 4.22 周四

#### 问题询问

1. jdk版本看清楚，pom文件里面的依赖和插件记得指定版本。

#### 学习记录

1. 当前端有关键字查询的时候，可以用like(key + "%")则代表有key做开头的记录，都加就是包含key的记录
2. 学习@Builder注解，用来快速优雅地生成一个对象。
3. 学习了Redis的基础知识
4. 学习了facade-admin里面的健康小课堂相关流程，看了相关授权的流程，但是有很多后台源代码没有显示，只有api接口。

### 4.23 周五

#### 问题询问

#### 学习记录

1. 进行修改的方法：

   新建一个Entity，然后调用save函数，在里面有差别，一个是persist插入，一个是merge修改。

   ```java
       public EC save(EC entity) {
           if (!entityManager.contains(entity)) {
               entityManager.persist(entity);
               return entity;
           } else {
               return entityManager.merge(entity);
           }
       }
   ```

   我们一般是会查出原本的entity然后调用相关的set函数，将entity改为我们需要的样子，之后再save(entity);

2. 学习数据库的sql语句写法

3. 看HealthCourseService里面的递归子树。

4. 写代码，尤其是调用别人的接口(如微服务、http请求的时候)，不要把业务逻辑放在@Transactional事务里面，因为调用失败会导致我们的事务回滚，或者http请求会被发两次，因为事务一次放到缓冲区，一次提交，都会执行一遍http请求，这样不安全。

   在写代码的时候我们要充分不相信别人，要悲观想象别人的代码，所以在调用的时候要经常记得加try catch捕捉异常。像调用http之类的要么异步执行要么try catch自己处理，不要让可能的异常直接让我们的业务挂掉。

5. 代码要记得ctrl + alt + l进行一个规范化！

6. 打印错误信息一定要注意不要直接加上一个dto，因为其toString方法是没有重写的，lombook虽然有提供，但是不能进行使用，所以要用JSON.toJSON()，这个json是alibaba的fastjson

7. 环境配置又有问题，引入maven文件

8. 写一个消息通知的接口，状况百出

9. 数据校验是前后端都要做的，比如身份证号、手机号等

### 第三周总结

总体来说写了一个最基础的代码，暴露了自己很多习惯不好的问题，比如代码规范化、命名规范化等。下个周继续多写代码，希望早点更加熟练，做出更好的成绩。

下周要多写代码，学习facade-admin项目，学习一些Java基础知识

## 第四周

### 4.27 星期二

#### 问题询问

#### 学习记录

1. 看dao需要的entity是哪一个可以去dao里面找到其继承的QueryDslBaseDao，如：

   ```java
   public class CodeDao extends QueryDslBaseDao<Code, QCode> 
   ```

   这里需要的entity已经说明了是Code

2. 正则表达式找到数字：

   ```java
   String useFreqNum = Pattern.compile("[^0-9]").matcher(useFreq).replaceAll("");
   ```

   找到小数和数字

   ```java
   Matcher m = Pattern.compile("(\\d+\\.\\d+)").matcher(singleDose);
               //找到说明是小数
               if (m.find()) {
                   String singleDoseDouble = m.group(1) == null ? "" : m.group(1);
                   double sdd = Double.parseDouble(singleDoseDouble);
                   uniNumDouble = uniNumDouble / useFreqNumber / sdd;
                   return (int) Math.ceil(uniNumDouble);
               }
   ```

   找小数或者是整数：

   ```java
   Matcher m = Pattern.compile("(\\d+\\.\\d+|\\d+)").matcher(singleDose);
   ```

   他们都能转为double，所以直接一起找就行，加一个|符号在括号里面就可以了

3. BigDecimal的目的是做一个精确的计算，因为double等类型在计算机底层里面的存储实际上是不精确的。

   用来对超过16位有效位的数进行精确的运算。double等只能处理最多十六位，商业计算里就要用这个

   BigDecimal一共有4个构造方法:

   BigDecimal(int) 创建一个具有参数所指定整数值的对象。

   BigDecimal(double) 创建一个具有参数所指定双精度值的对象。（不建议采用）因为本身的double是不确定的

   BigDecimal(long) 创建一个具有参数所指定长整数值的对象。

   BigDecimal(String) 创建一个具有参数所指定以字符串表示的数值的对象

   ```java
   public BigDecimal add(BigDecimal value); //加法
   public BigDecimal subtract(BigDecimal value); //减法
   public BigDecimal multiply(BigDecimal value); //乘法
   public BigDecimal divide(BigDecimal value); //除法
   ```

   这些的计算对象都是一个类型的，本次我写的主要是因为需求是Integer所以不需要这些函数进行计算。

   对于BigInteger，其主要目的是作为大数运算，当给的数字过大，超过了基本类型的时候就要用这个类型进行计算。

4. 用postman直接连接进行接口测试，但是body需要的dto是不能直接出现的，需要自己写内容。另外可以用swagger进行更方便的测试：http://localhost:8082/swagger-ui.html#/

#### 工作记录

1. 完成getUseDays()函数，学习了正则表达式提取数字的方法，了解了BigDecimal的精确性。
2. 为facade-admin里面的药物接口添加limitUseDays字段的添加修改和查询功能
3. 学习jbdoctor项目的common接口，学习设计模式

